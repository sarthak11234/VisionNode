[{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\ActionBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\AgentSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\AppShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\DataGrid.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\DataGrid.tsx:87:23\n  85 |     // Sync external value changes (e.g. from WebSocket)\n  86 |     useEffect(() => {\n> 87 |         if (!editing) setDraft(value);\n     |                       ^^^^^^^^ Avoid calling setState() directly within an effect\n  88 |     }, [value, editing]);\n  89 |\n  90 |     const commit = useCallback(() => {","line":87,"column":23,"nodeType":null,"endLine":87,"endColumn":31},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'react-hooks/rules-of-hooks' or 'react-hooks/exhaustive-deps').","line":203,"column":5,"severity":1,"nodeType":null,"fix":{"range":[6680,6807],"text":" "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\"use client\";\r\n\r\n/*\r\n * DataGrid ΓÇö Spreadsheet UI built on TanStack Table (Design.txt ┬º2, ┬º4)\r\n *\r\n * WHY TANSTACK TABLE (not AG Grid, Handsontable, or custom)?\r\n *   - Headless: We control 100% of the rendering ΓåÆ full design control\r\n *     for the HexaCore dark theme. AG Grid/Handsontable have their own\r\n *     DOM that's hard to override.\r\n *   - ~14KB gzipped vs AG Grid (~250KB) or Handsontable (~400KB)\r\n *   - React-first: hooks-based API, no imperative DOM manipulation\r\n *   - Free & MIT licensed (AG Grid community is limited, enterprise is $$$)\r\n *\r\n * TRADE-OFFS:\r\n *   - No built-in cell editing ΓÇö we implement it ourselves (below)\r\n *   - No built-in virtualization ΓÇö we'll add @tanstack/react-virtual\r\n *     in Phase 2 polish when row count > 1000\r\n *   - No drag-to-select ranges ΓÇö can be added with a pointer event layer\r\n *\r\n * DATA FLOW:\r\n *   1. Parent passes `columns` (from sheet.column_schema) and `rows` (from API)\r\n *   2. DataGrid renders them via TanStack Table\r\n *   3. On cell edit ΓåÆ calls onCellEdit(rowId, columnKey, newValue)\r\n *   4. Parent PATCHes the API + WebSocket broadcasts the change\r\n *\r\n * EDITABLE CELLS ALGORITHM:\r\n *   - Click a cell ΓåÆ it becomes an <input> (controlled by local state)\r\n *   - Press Enter or blur ΓåÆ commit the edit via onCellEdit callback\r\n *   - Press Escape ΓåÆ cancel the edit\r\n *   This is a \"click-to-edit\" pattern, the simplest and most reliable.\r\n *   ALTERNATIVE: \"always-editable\" (every cell is always an input) ΓÇö\r\n *   looks more like Excel but terrible for performance with 1000+ cells.\r\n */\r\n\r\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\r\nimport {\r\n    useReactTable,\r\n    getCoreRowModel,\r\n    flexRender,\r\n    type ColumnDef,\r\n    type CellContext,\r\n} from \"@tanstack/react-table\";\r\n\r\n/* ΓöÇΓöÇ Types ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */\r\n\r\nexport interface ColumnSchema {\r\n    key: string;\r\n    label: string;\r\n    type?: \"text\" | \"number\" | \"select\";\r\n}\r\n\r\nexport interface RowData {\r\n    id: string;\r\n    data: Record<string, string>;\r\n}\r\n\r\ninterface DataGridProps {\r\n    columns: ColumnSchema[];\r\n    rows: RowData[];\r\n    onCellEdit?: (rowId: string, columnKey: string, value: string) => void;\r\n    onRowSelect?: (rowIds: string[]) => void;\r\n}\r\n\r\n/* ΓöÇΓöÇ Editable Cell ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */\r\n\r\nfunction EditableCell({\r\n    value,\r\n    rowId,\r\n    columnKey,\r\n    onCommit,\r\n}: {\r\n    value: string;\r\n    rowId: string;\r\n    columnKey: string;\r\n    onCommit?: (rowId: string, columnKey: string, value: string) => void;\r\n}) {\r\n    const [editing, setEditing] = useState(false);\r\n    const [draft, setDraft] = useState(value);\r\n    const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n    useEffect(() => {\r\n        if (editing) inputRef.current?.focus();\r\n    }, [editing]);\r\n\r\n    // Sync external value changes (e.g. from WebSocket)\r\n    useEffect(() => {\r\n        if (!editing) setDraft(value);\r\n    }, [value, editing]);\r\n\r\n    const commit = useCallback(() => {\r\n        setEditing(false);\r\n        if (draft !== value) {\r\n            onCommit?.(rowId, columnKey, draft);\r\n        }\r\n    }, [draft, value, rowId, columnKey, onCommit]);\r\n\r\n    if (editing) {\r\n        return (\r\n            <input\r\n                ref={inputRef}\r\n                value={draft}\r\n                onChange={(e) => setDraft(e.target.value)}\r\n                onBlur={commit}\r\n                onKeyDown={(e) => {\r\n                    if (e.key === \"Enter\") commit();\r\n                    if (e.key === \"Escape\") {\r\n                        setDraft(value);\r\n                        setEditing(false);\r\n                    }\r\n                }}\r\n                style={{\r\n                    width: \"100%\",\r\n                    background: \"var(--bg-primary)\",\r\n                    border: \"1px solid var(--accent)\",\r\n                    boxShadow: \"var(--glow-accent)\",\r\n                    color: \"var(--text-primary)\",\r\n                    fontFamily: \"var(--font-mono)\",\r\n                    fontSize: 13,\r\n                    padding: \"4px 8px\",\r\n                    outline: \"none\",\r\n                    borderRadius: 2,\r\n                }}\r\n            />\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div\r\n            onDoubleClick={() => setEditing(true)}\r\n            style={{\r\n                padding: \"4px 8px\",\r\n                cursor: \"text\",\r\n                minHeight: 24,\r\n                fontFamily: \"var(--font-mono)\",\r\n                fontSize: 13,\r\n            }}\r\n            title=\"Double-click to edit\"\r\n        >\r\n            {value || \"\\u00A0\" /* non-breaking space for empty cells */}\r\n        </div>\r\n    );\r\n}\r\n\r\n/* ΓöÇΓöÇ Checkbox Column ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */\r\n\r\nconst checkboxColumn: ColumnDef<RowData> = {\r\n    id: \"select\",\r\n    header: ({ table }) => (\r\n        <input\r\n            type=\"checkbox\"\r\n            checked={table.getIsAllRowsSelected()}\r\n            onChange={table.getToggleAllRowsSelectedHandler()}\r\n            style={{ accentColor: \"var(--accent)\" }}\r\n        />\r\n    ),\r\n    cell: ({ row }) => (\r\n        <input\r\n            type=\"checkbox\"\r\n            checked={row.getIsSelected()}\r\n            onChange={row.getToggleSelectedHandler()}\r\n            style={{ accentColor: \"var(--accent)\" }}\r\n        />\r\n    ),\r\n    size: 40,\r\n};\r\n\r\n/* ΓöÇΓöÇ DataGrid Component ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */\r\n\r\nexport default function DataGrid({\r\n    columns,\r\n    rows,\r\n    onCellEdit,\r\n    onRowSelect,\r\n}: DataGridProps) {\r\n    const [rowSelection, setRowSelection] = useState<Record<string, boolean>>({});\r\n\r\n    // Build TanStack column defs from our column schema\r\n    // useMemo prevents re-creation on every render (react-hooks/exhaustive-deps)\r\n    const tableColumns: ColumnDef<RowData>[] = useMemo(\r\n        () => [\r\n            checkboxColumn,\r\n            ...columns.map((col) => ({\r\n                id: col.key,\r\n                accessorFn: (row: RowData) => row.data[col.key] ?? \"\",\r\n                header: () => (\r\n                    <span style={{ fontFamily: \"var(--font-heading)\", fontWeight: 600, fontSize: 12, textTransform: \"uppercase\" as const, letterSpacing: \"0.05em\" }}>\r\n                        {col.label}\r\n                    </span>\r\n                ),\r\n                cell: (info: CellContext<RowData, unknown>) => (\r\n                    <EditableCell\r\n                        value={String(info.getValue())}\r\n                        rowId={info.row.original.id}\r\n                        columnKey={col.key}\r\n                        onCommit={onCellEdit}\r\n                    />\r\n                ),\r\n            })),\r\n        ],\r\n        [columns, onCellEdit]\r\n    );\r\n\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks, react-hooks/exhaustive-deps -- useReactTable manages its own reactivity\r\n    const table = useReactTable({\r\n        data: rows,\r\n        columns: tableColumns,\r\n        state: { rowSelection },\r\n        onRowSelectionChange: (updater) => {\r\n            const next = typeof updater === \"function\" ? updater(rowSelection) : updater;\r\n            setRowSelection(next);\r\n            // Notify parent of selected row IDs\r\n            const selectedIds = Object.keys(next).filter((k) => next[k]).map((idx) => rows[Number(idx)]?.id).filter(Boolean);\r\n            onRowSelect?.(selectedIds);\r\n        },\r\n        getCoreRowModel: getCoreRowModel(),\r\n        getRowId: (row) => row.id,\r\n    });\r\n\r\n    return (\r\n        <div style={{ overflowX: \"auto\", borderRadius: 8, border: \"1px solid var(--border-subtle)\" }}>\r\n            <table\r\n                style={{\r\n                    width: \"100%\",\r\n                    borderCollapse: \"collapse\",\r\n                    fontFamily: \"var(--font-mono)\",\r\n                    fontSize: 13,\r\n                }}\r\n            >\r\n                {/* ΓöÇΓöÇ Head ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */}\r\n                <thead>\r\n                    {table.getHeaderGroups().map((hg) => (\r\n                        <tr key={hg.id}>\r\n                            {hg.headers.map((header) => (\r\n                                <th\r\n                                    key={header.id}\r\n                                    style={{\r\n                                        padding: \"10px 12px\",\r\n                                        textAlign: \"left\",\r\n                                        borderBottom: \"1px solid var(--border)\",\r\n                                        background: \"var(--bg-secondary)\",\r\n                                        color: \"var(--text-secondary)\",\r\n                                        position: \"sticky\",\r\n                                        top: 0,\r\n                                        zIndex: 10,\r\n                                        width: header.getSize(),\r\n                                    }}\r\n                                >\r\n                                    {header.isPlaceholder\r\n                                        ? null\r\n                                        : flexRender(header.column.columnDef.header, header.getContext())}\r\n                                </th>\r\n                            ))}\r\n                        </tr>\r\n                    ))}\r\n                </thead>\r\n\r\n                {/* ΓöÇΓöÇ Body ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ */}\r\n                <tbody>\r\n                    {table.getRowModel().rows.length === 0 ? (\r\n                        <tr>\r\n                            <td\r\n                                colSpan={tableColumns.length}\r\n                                style={{\r\n                                    textAlign: \"center\",\r\n                                    padding: 40,\r\n                                    color: \"var(--text-tertiary)\",\r\n                                }}\r\n                            >\r\n                                No rows yet ΓÇö import a CSV or create a row\r\n                            </td>\r\n                        </tr>\r\n                    ) : (\r\n                        table.getRowModel().rows.map((row) => (\r\n                            <tr\r\n                                key={row.id}\r\n                                style={{\r\n                                    borderBottom: \"1px solid var(--border-subtle)\",\r\n                                    background: row.getIsSelected()\r\n                                        ? \"rgba(9, 5, 254, 0.08)\"\r\n                                        : \"transparent\",\r\n                                    transition: \"background 0.1s ease\",\r\n                                }}\r\n                                onMouseEnter={(e) => {\r\n                                    if (!row.getIsSelected())\r\n                                        e.currentTarget.style.background = \"var(--bg-tertiary)\";\r\n                                }}\r\n                                onMouseLeave={(e) => {\r\n                                    if (!row.getIsSelected())\r\n                                        e.currentTarget.style.background = \"transparent\";\r\n                                }}\r\n                            >\r\n                                {row.getVisibleCells().map((cell) => (\r\n                                    <td\r\n                                        key={cell.id}\r\n                                        style={{\r\n                                            padding: \"2px 4px\",\r\n                                            borderRight: \"1px solid var(--border-subtle)\",\r\n                                        }}\r\n                                    >\r\n                                        {flexRender(cell.column.columnDef.cell, cell.getContext())}\r\n                                    </td>\r\n                                ))}\r\n                            </tr>\r\n                        ))\r\n                    )}\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\components\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\app\\providers\\QueryProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\hooks\\useSheetData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\hooks\\useSheetSocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sarth\\OneDrive\\Desktop\\Omni\\VisionNode\\client\\src\\lib\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
